import { type NextRequest, NextResponse } from "next/server"
import { Octokit } from "@octokit/rest"

interface GitHubPushRequest {
  projectId: string
  repoName: string
  files: Array<{
    path: string
    content: string
  }>
  githubToken: string
  paymentId: string
}

// Import the payments map to verify payment
const pendingPayments = new Map<string, any>()

async function createOrUpdateRepository(
  octokit: Octokit,
  repoName: string,
  files: Array<{ path: string; content: string }>,
  commitMessage = "Deploy from WebCraft Studio",
) {
  try {
    const { data: user } = await octokit.rest.users.getAuthenticated()
    const owner = user.login

    let repo
    try {
      const { data: existingRepo } = await octokit.rest.repos.get({
        owner,
        repo: repoName,
      })
      repo = existingRepo
    } catch (error: any) {
      if (error.status === 404) {
        const { data: newRepo } = await octokit.rest.repos.createForAuthenticatedUser({
          name: repoName,
          description: "Generated by WebCraft Studio",
          private: false,
          auto_init: true,
        })
        repo = newRepo
        await new Promise((resolve) => setTimeout(resolve, 2000))
      } else {
        throw error
      }
    }

    const { data: branches } = await octokit.rest.repos.listBranches({
      owner,
      repo: repoName,
    })

    const defaultBranch = branches.find((b) => b.name === repo.default_branch) || branches[0]
    if (!defaultBranch) {
      throw new Error("No branches found in repository")
    }

    const { data: latestCommit } = await octokit.rest.git.getCommit({
      owner,
      repo: repoName,
      commit_sha: defaultBranch.commit.sha,
    })

    const blobs = await Promise.all(
      files.map(async (file) => {
        const { data: blob } = await octokit.rest.git.createBlob({
          owner,
          repo: repoName,
          content: Buffer.from(file.content).toString("base64"),
          encoding: "base64",
        })

        return {
          path: file.path,
          mode: "100644" as const,
          type: "blob" as const,
          sha: blob.sha,
        }
      }),
    )

    const { data: tree } = await octokit.rest.git.createTree({
      owner,
      repo: repoName,
      base_tree: latestCommit.tree.sha,
      tree: blobs,
    })

    const { data: commit } = await octokit.rest.git.createCommit({
      owner,
      repo: repoName,
      message: commitMessage,
      tree: tree.sha,
      parents: [latestCommit.sha],
    })

    await octokit.rest.git.updateRef({
      owner,
      repo: repoName,
      ref: `heads/${repo.default_branch}`,
      sha: commit.sha,
    })

    return {
      repoUrl: repo.html_url,
      commitSha: commit.sha,
      commitUrl: `${repo.html_url}/commit/${commit.sha}`,
      branch: repo.default_branch,
    }
  } catch (error) {
    console.error("GitHub operation failed:", error)
    throw error
  }
}

export async function POST(request: NextRequest) {
  try {
    const { projectId, repoName, files, githubToken, paymentId }: GitHubPushRequest = await request.json()

    if (!projectId || !repoName || !files || !githubToken || !paymentId) {
      return NextResponse.json({ error: "All fields are required" }, { status: 400 })
    }

    // Verify payment
    const payment = pendingPayments.get(paymentId)
    if (!payment || payment.status !== "completed" || payment.service !== "github") {
      return NextResponse.json({ error: "Valid payment required for GitHub integration" }, { status: 402 })
    }

    const repoNameRegex = /^[a-zA-Z0-9._-]+$/
    if (!repoNameRegex.test(repoName)) {
      return NextResponse.json({ error: "Invalid repository name" }, { status: 400 })
    }

    const octokit = new Octokit({ auth: githubToken })

    const validFiles = files.filter(
      (file) => file.path && file.content && file.path.length > 0 && file.content.length > 0,
    )

    if (validFiles.length === 0) {
      return NextResponse.json({ error: "No valid files to push" }, { status: 400 })
    }

    // Add README if not present
    const hasReadme = validFiles.some((file) => file.path.toLowerCase().includes("readme"))
    if (!hasReadme) {
      validFiles.push({
        path: "README.md",
        content: `# ${repoName}

This website was generated by WebCraft Studio.

## Getting Started

\`\`\`bash
npm install
npm run dev
\`\`\`

## Deployment

This project is ready to deploy to Vercel, Netlify, or any other hosting platform.

---

Generated on ${new Date().toLocaleDateString()}
`,
      })
    }

    const result = await createOrUpdateRepository(octokit, repoName, validFiles)

    return NextResponse.json({
      success: true,
      data: result,
    })
  } catch (error: any) {
    console.error("GitHub push error:", error)

    if (error.status === 401) {
      return NextResponse.json({ error: "GitHub authentication failed" }, { status: 401 })
    }

    if (error.status === 403) {
      return NextResponse.json({ error: "GitHub access denied" }, { status: 403 })
    }

    return NextResponse.json({ error: "Failed to push to GitHub" }, { status: 500 })
  }
}
